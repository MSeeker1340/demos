/* Generated by autotuner.py */
/* tile width = 32, loop unroll = False */
__global__ void matmul(double *M, double *N, double *P, int Width)
{
    // Compute M * N and store result in P
    // M and N are Width * Width matrices
    __shared__ double Ms[32][32];
    __shared__ double Ns[32][32];
    int tx = threadIdx.x;
    int ty = threadIdx.y;
    int Row = blockIdx.y * 32 + ty;
    int Col = blockIdx.x * 32 + tx;

    double Pvalue = 0.0;
    for (int ph = 0; ph < ceil(Width / (double)32); ++ph)
    {
        // Cooperatively load tile into shared memory
        if (Row < Width && ph*32 + tx < Width)
        {
            Ms[ty][tx] = M[Row*Width + ph*32 + tx];
        }
        else
        {
            Ms[ty][tx] = 0.0;
        }
        if (Col < Width && ph*32 + ty < Width)
        {
            Ns[ty][tx] = N[(ph*32 + ty)*Width + Col];
        }
        else
        {
            Ns[ty][tx] = 0.0;
        }
        __syncthreads();

        for (int k = 0; k < 32; ++k)
        {
            Pvalue += Ms[ty][k] * Ns[k][tx];
        }
        __syncthreads();
    }

    if (Row < Width && Col < Width)
    {
        P[Row*Width + Col] = Pvalue;
    }
}
